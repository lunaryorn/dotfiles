#!/usr/bin/env python3
# Copyright 2020 Sebastian Wiesner <sebastian@swsnr.de>
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.

import logging
import sys
import json
from subprocess import Popen, DEVNULL
from enum import IntEnum
from gi.repository import GLib, Gio
from systemd.journal import JournalHandler
from urllib.request import urlopen
from shutil import copyfileobj

import gi
gi.require_version('Geoclue', '2.0')


LOG = logging.getLogger('i3blocks.blocklets.weather')


def weather_url_for_current_location(geoclue):
    location = geoclue.get_location()
    lat = round(location.get_property('latitude'), 1)
    lon = round(location.get_property('longitude'), 1)
    return f'https://wttr.in/{lat},{lon}'


def print_weather(geoclue):
    url = weather_url_for_current_location(geoclue)
    LOG.debug(f'Receiving weather from {url}')
    with urlopen(f'{url}?format=%c%t') as source:
        info = source.read().decode('utf-8')
        LOG.debug(f'Got weather from {url}: {info}')
    output = {'full_text': info}
    json.dump(output, sys.stdout, ensure_ascii=False, indent=None)
    sys.stdout.write('\n')
    sys.stdout.flush()


def print_weather_safe(geoclue):
    try:
        print_weather(geoclue)
    except Exception as error:
        LOG.exception(f'Failed to print weather information: {error}')


def _update_on_timer(geoclue):
    LOG.debug('Updating weather on timer')
    print_weather_safe(geoclue)
    return True


def _start(geoclue):
    LOG.info('Connected to geoclue, receiving initial weather information')
    print_weather_safe(geoclue)
    # Don't repeat the initial timeout
    return False


class Button(IntEnum):
    LEFT = 1
    MIDDLE = 2
    RIGHT = 3


class ButtonHandler():
    def __init__(self, on_left_click):
        self._on_left_click = on_left_click

    def handle_event(self, channel, condition):
        try:
            if channel == 0 and condition == GLib.IO_IN:
                line = next(sys.stdin)
                LOG.debug(f'Got stdin: {line}')
                event = json.loads(line)
                LOG.debug(f'button event: {event}')
                if event['button'] == Button.LEFT and not event['modifiers']:
                    self._on_left_click()
        except Exception as error:
            LOG.exception(f'Failed to handle button event: {error}')

        # Keep watching events indefinitely
        return True


def open_weather(geoclue):
    try:
        url = weather_url_for_current_location(geoclue)
        Popen(['xdg-open', url], stdout=DEVNULL, stderr=DEVNULL)
    except Exception as error:
        LOG.exception(f'Failed to open weather page in browser: {error}')


def main():
    logging.getLogger().addHandler(JournalHandler())
    LOG.setLevel(logging.INFO)

    try:
        from gi.repository import Geoclue
        geoclue = Geoclue.Simple.new_sync(
            'i3blocks-weather', Geoclue.AccuracyLevel.CITY, None)

        # Refresh weather immediately and once every hour
        GLib.timeout_add(0, lambda: _start(geoclue))
        GLib.timeout_add_seconds(3600, lambda: _update_on_timer(geoclue))

        # Handle button events from i3
        GLib.io_add_watch(0, GLib.IO_IN, ButtonHandler(
            on_left_click=lambda: open_weather(geoclue)).handle_event)

        GLib.MainLoop().run()
    except Exception as error:
        LOG.exception(f'Failed to connect to geoclue: {error}')
        sys.exit(1)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass
