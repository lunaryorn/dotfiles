#!/usr/bin/env python3
# Copyright 2019 Sebastian Wiesner <sebastian@swsnr.de>
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.


import os
import sys
import subprocess
import json
from urllib.parse import urlparse
from time import time
from pathlib import Path
from collections import Counter, namedtuple

from gi.repository import Gio


Project = namedtuple('Project', 'name path')


CANDIDATES = [
    # Standard Code OSS build on Arch Linux.
    ("code-oss.desktop", "Code - OSS"),
    # Offical VSCode snap
    ("code_code.desktop", "Code"),
]


def find_vscode():
    for (desktop_name, config_dir) in CANDIDATES:
        try:
            return (Gio.DesktopAppInfo.new(desktop_name), config_home() / config_dir)
        # pygobject raises a type error if new returns NULL, for whatever reason
        except TypeError:
            continue

    else:
        return (None, None)


def get_data_home():
    data_home = os.environ.get('XDG_DATA_HOME')
    if data_home:
        return Path(data_home)
    else:
        return Path.home() / '.local' / 'share'


def get_recent_file():
    return get_data_home() / 'rofi' / 'code-recent-projects.json'


def read_recent_entries():
    try:
        return json.loads(get_recent_file().read_text())
    except FileNotFoundError:
        return {}


def write_recent_entries(entries):
    target = get_recent_file()
    target.parent.mkdir(parents=True, exist_ok=True)
    target.write_text(json.dumps(entries))


def config_home():
    return Path(os.environ.get('XDG_CONFIG_HOME', Path.home() / '.config'))


def workspace_name(workspace_dir):
    return str(workspace_dir).replace(str(Path.home()), '~')


def read_projects(file):
    with file.open() as source:
        storage = json.load(source)
    workspaces = [urlparse(uri) for uri in storage.get(
        'openedPathsList', {}).get('workspaces3', [])]
    # We only support local workspaces
    local_workspaces = [Path(uri.path) for uri in workspaces if not uri.netloc]
    projects = [Project(workspace_name(path), path)
                for path in local_workspaces]
    duplicates = [name for name, count
                  in Counter(p.name for p in projects).items()
                  if 1 < count]
    if duplicates:
        raise ValueError('Duplicate project name: {}', ', '.join(duplicates))
    return dict((p.name, p) for p in projects)


def main():
    (code, config_dir) = find_vscode()
    if not code:
        return

    projects = read_projects(config_dir / 'storage.json')
    recent = read_recent_entries()
    if len(sys.argv) == 1:
        print('\x00prompt\x1fCode workspace')
        icon = code.get_icon().get_file().get_path()
        sorted_by_recent = sorted(
            projects.keys(), key=lambda n: (recent.get(n, 0) * -1, n))
        for project_name in sorted_by_recent:
            print('{}\x00icon\x1f{}'.format(project_name, icon))
    else:
        print()
        name = sys.argv[1]
        path = projects[name].path
        recent[name] = time()
        write_recent_entries(recent)
        code.launch([Gio.File.new_for_path(str(path.expanduser()))], None)


if __name__ == '__main__':
    main()
