#!/usr/bin/env python3
# Copyright 2020 Sebastian Wiesner <sebastian@swsnr.de>
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.

import sys
import logging
import json
from systemd.journal import JournalHandler
from gi.repository import Gio, GLib
from enum import IntEnum


LOG = logging.getLogger('i3blocks.blocklets.vpn')


class NMActiveConnectionState(IntEnum):
    """
    See https://developer.gnome.org/NetworkManager/stable/nm-dbus-types.html#NMActiveConnectionState
    """
    UNKNOWN = 0
    ACTIVATING = 1
    ACTIVATED = 2
    DEACTIVATING = 3
    DEACTIVATED = 4


class VPNBlocket:
    def __init__(self):
        self.networkmanager = Gio.DBusProxy.new_for_bus_sync(
            Gio.BusType.SYSTEM, Gio.DBusProxyFlags.NONE, None,
            'org.freedesktop.NetworkManager',
            '/org/freedesktop/NetworkManager',
            'org.freedesktop.NetworkManager'
        )

        self._active_vpns = {}

    def _connection(self, path):
        return Gio.DBusProxy.new_sync(
            self.networkmanager.get_connection(),
            Gio.DBusProxyFlags.NONE, None,
            self.networkmanager.get_name(),
            path,
            'org.freedesktop.NetworkManager.Connection.Active'
        )

    def _print_vpn(self, connection):
        id = connection.get_cached_property('Id').unpack()
        state = connection.get_cached_property('State').unpack()
        if state == NMActiveConnectionState.ACTIVATED:
            color = '#8BC34A'
        else:
            color = '#f57900'
        return f'<span foreground="{color}">ðŸ–§{id}</span>'

    def _print_vpns(self):
        connections = sorted(
            (c['connection'] for c in self._active_vpns.values()),
            key=lambda c: c.get_cached_property('Id').unpack()
        )

        output = {'full_text': ' '.join(
            self._print_vpn(c) for c in connections)}
        json.dump(output, sys.stdout, ensure_ascii=False, indent=None)
        sys.stdout.write('\n')
        sys.stdout.flush()

    def _handle_vpn_changed(self, connection, changed_props, _invalidated_props):
        changed_props = changed_props.unpack()
        path = connection.get_object_path()
        LOG.debug(f'Received change for connection {path}: {changed_props}')
        try:
            if path not in self._active_vpns:
                LOG.warning(f'Change received for unknown VPN: {path}')
                return

            if any(p in changed_props for p in ['Id', 'State']):
                self._print_vpns()

        except Exception as error:
            LOG.exception(
                f'Failed to handle change of {path}: {error}')

    def _maybe_add_vpn(self, path):
        if path in self._active_vpns:
            # We already know about this connection
            return False
        connection = self._connection(path)
        is_vpn = connection.get_cached_property('Vpn')
        if is_vpn and is_vpn.unpack():
            LOG.info(f'Tracking new VPN connection at {path}')
            self._active_vpns[path] = {
                'connection': connection,
                '_signal_id': connection.connect('g-properties-changed', self._handle_vpn_changed)
            }
            return True
        else:
            return False

    def _remove_vpn(self, path):
        LOG.info(f'No longer tracking disconnected VPN at {path}')
        data = self._active_vpns[path]
        data['connection'].disconnect(data['_signal_id'])
        del self._active_vpns[path]

    def _update_vpns(self, connections):
        needs_update = False
        # Register all potentially new connections
        for connection in connections:
            if self._maybe_add_vpn(connection):
                needs_update = True

        # Remove all deactivated connections
        connections_to_remove = [
            c for c in self._active_vpns if c not in connections]
        for connection in connections_to_remove:
            needs_update = True
            self._remove_vpn(connection)

        if needs_update:
            self._print_vpns()

    def _handle_nm_changed(self, _nm, changed_props, _invalidated_props):
        active_connections = changed_props.unpack().get('ActiveConnections')
        if active_connections:
            try:
                LOG.debug(f'Active connections changed: {active_connections}')
                self._update_vpns(active_connections)
            except Exception as error:
                LOG.exception(
                    f'Failed to update VPNS from {active_connections}: {error}')

    def start(self):
        self.networkmanager.connect(
            'g-properties-changed', self._handle_nm_changed)
        active_connections = self.networkmanager.get_cached_property(
            'ActiveConnections').unpack()
        for path in active_connections:
            self._maybe_add_vpn(path)
        self._print_vpns()


def main():
    logging.getLogger().addHandler(JournalHandler())
    LOG.setLevel(logging.INFO)

    try:
        blocket = VPNBlocket()
        blocket.start()
        GLib.MainLoop().run()
    except Exception as error:
        LOG.exception(f'Failed to start blocket: {error}')
        sys.exit(1)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass
