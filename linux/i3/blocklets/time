#!/usr/bin/env python3
# Copyright 2020 Sebastian Wiesner <sebastian@swsnr.de>
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.

import os
import sys
import logging
from systemd.journal import JournalHandler
from locale import LC_ALL, setlocale
from datetime import datetime
from gi.repository import Gio, GLib


LOG = logging.getLogger('i3blocks.blocklets.time')


class TimeBlocklet:
    def __init__(self):
        self._timer_source = None
        self.logind = Gio.DBusProxy.new_for_bus_sync(
            Gio.BusType.SYSTEM, Gio.DBusProxyFlags.DO_NOT_LOAD_PROPERTIES | Gio.DBusProxyFlags.DO_NOT_CONNECT_SIGNALS, None,
            'org.freedesktop.login1',
            '/org/freedesktop/login1',
            'org.freedesktop.login1.Manager'
        )

        session_id = os.environ.get('XDG_SESSION_ID')
        if session_id:
            session_path = self.logind.GetSession('(s)', session_id)
        else:
            session_path = self.logind.GetSessionByPID('(u)', os.getpid())
        self.session = Gio.DBusProxy.new_sync(
            self.logind.get_connection(), Gio.DBusProxyFlags.NONE, None,
            self.logind.get_name(),
            session_path,
            'org.freedesktop.login1.Session'
        )
        LOG.debug(f'Connected to session at {session_path}')

    def start(self):
        self.session.connect('g-properties-changed', self._session_changed)
        self._resume()

    def _resume(self):
        if not self._timer_source:
            LOG.debug('Resuming time blocklet')
            self._print_time()
            self._timer_source = GLib.timeout_add_seconds(60, self._print_time)

    def _pause(self):
        if self._timer_source:
            LOG.debug('Resuming time blocklet')
            GLib.source_remove(self._timer_source)
            self._timer_source = None

    def _session_changed(self, _session, changed_properties, _invalidated_properties):
        try:
            locked = changed_properties.unpack().get('LockedHint', None)
            if locked is False:
                LOG.info('Session unlocked, updating clock again')
                self._resume()
            elif locked is True:
                LOG.info('Session locked, pausing clock updates')
                self._pause()
        except Exception as error:
            LOG.exception(f'Failed to handle session state change: {error}')

    def _print_time(self):
        try:
            sys.stdout.write(datetime.today().strftime('üï∞Ô∏è %H:%M'))
            sys.stdout.write('\n')
            sys.stdout.flush()
            # Keep the glib timeout alive
        except Exception as error:
            LOG.exception(f'Failed to print time: {error}')

        return True


def main():
    logging.getLogger().addHandler(JournalHandler())
    LOG.setLevel(logging.INFO)

    try:
        setlocale(LC_ALL, '')

        TimeBlocklet().start()
        GLib.MainLoop().run()
    except Exception as error:
        LOG.exception(f'Failed to start blocket: {error}')
        sys.exit(1)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass
