#!/usr/bin/env python3
# Copyright 2019 Sebastian Wiesner <sebastian@swsnr.de>
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.


import os
import sys
import xml.etree.ElementTree as etree
import subprocess
import json
from time import time
from pathlib import Path
from collections import namedtuple
from gi.repository import Gio


# TODO: Adapt for clion and webstorm!


CANDIDATES = [
    # Toolbox installation
    "jetbrains-idea.desktop",
    # Snap installation
    "intellij-idea-ultimate_intellij-idea-ultimate.desktop",
]


Project = namedtuple('Project', 'name path')


def get_config_home():
    return Path(os.environ.get('XDG_CONFIG_HOME', Path.home() / '.config'))


def get_data_home():
    return Path(os.environ.get('XDG_DATA_HOME', Path.home() / '.local' / 'share'))


def get_recent_file():
    return get_data_home() / 'rofi' / 'idea-recent-projects.json'


def read_recent_entries():
    try:
        return json.loads(get_recent_file().read_text())
    except FileNotFoundError:
        return {}


def write_recent_entries(entries):
    target = get_recent_file()
    target.parent.mkdir(parents=True, exist_ok=True)
    target.write_text(json.dumps(entries))


def find_idea():
    for candidate in CANDIDATES:
        try:
            return Gio.DesktopAppInfo.new(candidate)
        except TypeError:
            # For whatever reason pygobject raises a type error if new returns NULL
            continue
    else:
        return None


def latest_config_file():
    candidates = sorted(
        (get_config_home() / 'JetBrains').glob('IntelliJIdea*'),
        key=lambda p: p.name,
        reverse=True)
    if candidates:
        return candidates[0] / 'options' / 'recentProjects.xml'
    else:
        return None


def read_project(directory):
    namefile = directory.expanduser() / '.idea' / '.name'
    try:
        name = namefile.read_text(encoding='utf-8').strip()
    except FileNotFoundError:
        name = directory.name
    return Project(name=name, path=directory)


def read_projects(file):
    document = etree.parse(file)
    paths = (Path(el.attrib['value'].replace('$USER_HOME$', '~'))
             for el in
             document.findall('.//option[@name="recentPaths"]/list/option'))
    projects = [read_project(directory) for directory in paths if
                directory.expanduser().is_dir()]
    return dict((p.path, p) for p in projects)


def get_icon_name(app):
    icon = app.get_icon()
    if isinstance(icon, Gio.FileIcon):
        return icon.get_file().get_path()
    elif isinstance(icon, Gio.ThemedIcon):
        return icon.get_names()[0]
    else:
        raise ValueError(f'Cannot get icon name for {icon!r}')


def main():
    idea = find_idea()
    config_file = latest_config_file()
    if not (idea and config_file):
        return
    projects = read_projects(config_file)
    recent = read_recent_entries()
    if len(sys.argv) == 1:
        print('\x00prompt\x1fIDEA Project')
        print('\x00no-custom\x1ftrue')
        icon_name = get_icon_name(idea) or ''
        sorted_by_recent = sorted(
            projects.values(), key=lambda p: (recent.get(p.path, 0) * -1, p.name))
        for project in sorted_by_recent:
            print('{}\x00icon\x1f{}\x1finfo\x1f{}'.format(
                project.name, icon_name, project.path))
    else:
        print()
        path = os.environ.get('ROFI_INFO')
        recent[path] = time()
        write_recent_entries(recent)
        subprocess.run(['gtk-launch', idea.get_id(), Path(path).expanduser().as_uri()],
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)


if __name__ == '__main__':
    main()
